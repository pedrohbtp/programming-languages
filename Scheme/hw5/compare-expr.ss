;------------------------------
; Definition of variables used for testing 
;------------------------------
; My test-x and test-y definitions
(define test-x '(list
                        "hello"
                        (* 10 (let ((a 1))
                                   (if (equal? a 1)
                                        ((lambda (b) (+ b 9)) a)
                                        (+ a 42)
                                   )
                               ) 
                        )
                        #t
                        #f
                        #t
                        #f
                        1
                        (quote (c d))
                        '(2 10)
                        (cons 10 9)
                        (list 9 7)
                )
)

(define test-y '(list
                    "hello"
                    (* 10 (let ((a 3))
                               (if (equal? a 3)
                                    ((lambda (b) (+ b 7)) a)
                                    (+ a a)
                                )
                           ) 
                    )
                    #t
                    #f
                    #f
                    #t
                    1
                    (quote (c d))
                    '(2 5)
                    (list 10 9)
                    (cons 0 7)
                )
)

; test-x and test-y definitions given as example
; by the problem description
(define test-x-example '(+ 3 (let ((a 1) (b 2)) (list a b))))
(define test-y-example '(+ 2 (let ((a 1) (c 2)) (list a c))))


;------------------------------
; Compare Scheme expressions 
;------------------------------
; Main function used to generate comparison expressions. 
(define (compare-expr x y)
    (match (list x y)
          [(list (list 'if compx thenx elsex) (list 'if compy theny elsey) ) (compare_ifs compx compy thenx theny elsex elsey)]
          ; If one is an if and the other is another function
          [(list (list 'if compx thenx elsex) _ ) (if_tcp x y)]
          [(list _ (list 'if compy theny elsey) ) (if_tcp x y)]
           ; If matches a lambda function
          [(list (list 'lambda formalsx bodyx) (list 'lambda formalsy bodyy)) (compare_lambdas formalsx formalsy bodyx bodyy)]
           ; If one is lambda but the other one is not
          [(list (list 'lambda formalsx bodyx) _ ) (if_tcp x y)]
          [(list _ (list 'lambda formalsx bodyx) ) (if_tcp x y)]
          [(list (list 'quote datax) (list 'quote datay)) (compare_quotes datax datay)]
          ; If one is quote and the other is not
          [(list (list 'quote datax) _ ) (if_tcp x y)]
          [(list _ (list 'quote datax) ) (if_tcp x y)]
          [(list (list 'let bindingsx bodyx) (list 'let bindingsy bodyy)) (compare_lets bindingsx bindingsy bodyx bodyy)]
          ; If one is let and the other is not
          [(list (list 'let bindingsx bodyx) _ ) (if_tcp x y)]
          [(list _ (list 'let bindingsx bodyx) ) (if_tcp x y)]
           ;Else if both x and y are lists or literals
           [(list varx vary) (compare_lists varx vary)]
           
           
    )
)

; Receives two expressions generated by the "compare-expr" function and 
; evaluate them using "eval".
; If evaluating x is equal to evaluating (compare-expr x y) with TCP=#t
; and evaluating y is equal to evaluating (compare-expr x y) with TCP=#f
; then return true, else false
(define (test-compare-expr x y)
    (if (and 
              (equal? (eval x) (eval (assign_TCP x y #t)))
              (equal? (eval y) (eval (assign_TCP x y #f)))   
        )
        ; then
        #t
        ;else
        #f
    )
)

; Auxiliary function used to assign
; a value to the variable TCP
; tcp_val should be a boolean
; Example: (assign_TCP 1 2 #t) => 1
; Example: (assign_TCP 2 2 #t) => 2
; Example: (assign_TCP ''(a b) ''(a c)) => 
(define (assign_TCP x y tcp_val)
        `(let ((TCP ,tcp_val)) ,(compare-expr x y) )
)
;Function to check if expression is an atom
(define (atom? x) (not (or (pair? x) (null? x))))

; Used to make expressions like (if TCP 1 2)
(define (if_tcp x y)
     `(if ,'TCP  ,x ,y)
)


; Receives 4 arguments representing the expressions 
; that make two lets
; Example: (compare_lets '('(a b) '(a b)) '('(a b) '(a b)) '(f) '(g)) => '(let ('(a b) '(a b)) ((if TCP f g)))
(define (compare_lets bindingsx bindingsy bodyx bodyy)
    (cond 
          [(compare_bindings bindingsx bindingsy) `(let ,(compare-expr bindingsx bindingsy) ,(compare-expr bodyx bodyy) )]
          [else (if_tcp `(let ,bindingsx ,bodyx) `(let ,bindingsy ,bodyy ))]
    )
)

;Receives two lists representing the bindings of a let function.
; Compares the first element of each of the sublists.
; The lists should have the same length
; Example: (compare_bindings '((a 2) (b 2)) '((a 3) (b 4))) => #t
; Example: (compare_bindings '((a 2) (b 2)) '((a 2) (c 2))) => #f
(define (compare_bindings bindingsx bindingsy)
    (cond
        ; Base case
        [(empty? bindingsx) #t]
        ; In case the heads are different
        [(not (equal? (car (car bindingsx)) (car (car bindingsy)))) #f]
        ; Else, the heads are the same, so keep comparing the other heads
        [else (compare_bindings (cdr bindingsx) (cdr bindingsy))]
    )
)

; Receives 4 arguments representing the expressions 
; that make two lambdas
; Example:  (compare_lambdas '(a b) '(a b) '(f a b) '(f b c)) => (lambda (a b) (f (if TCP (a b)) (if TCP (b c))))
; Example: (compare_lambdas '(a b) '(a b) '(f b) '(f b)) => (lambda (a b) (f b))
; Example: (compare_lambdas '(a b) '(a c) '(f b) '(f b)) => (if TCP (lambda (a b) (f b)) (lambda (a c) (f b)) )
(define (compare_lambdas formalsx formalsy bodyx bodyy)
    (cond 
          [(equal? formalsx formalsy) `(lambda ,formalsx ,(compare-expr bodyx bodyy) )]
          [else (if_tcp `(lambda ,formalsx ,bodyx) `(lambda ,formalsy ,bodyy))]
    )
)

; Receives 6 arguments representing 2 ifs.
; Compare the expressions 
(define (compare_ifs compx compy thenx theny elsex elsey)
    `(if ,(compare-expr compx compy) ,(compare-expr thenx theny) ,(compare-expr elsex elsey))
    ; (cond
        ; If the comparison of the ifs are equal, then check the then and else statements
        ;[(equal? compx compy) `(if ,compx ,(compare-expr thenx theny) ,(compare-expr elsex elsey))]
        ; If the arguments of the if are different, we consider the entire expression is different
        ;[else (if_tcp `(if ,compx ,thenx ,elsex) `(if ,compy ,theny ,elsey))]
    ; )
)

; Receives two lists, both of length one and treat them
(define (proc_length1_lists x y)
    (cond
        ; if both x and y have lists within
        ; Then process the inner list calling the 
        ; main function
        [(and (list? (car x)) (list? (car y))) (list (compare-expr (car x) (car y)))]   
        ; If only x or only y have lists within, then they are different beings
        [(or (list? (car x)) (list? (car y))) (list (if_tcp x y))]
        ; Else none of them have lists within, them process its element
        [else (list (compare-expr (car x) (car y)))]
    )
)

; Receives two lists or atoms. Recur over them to compare each element
(define (compare_lists x y)
    (cond
    [(or (atom? x) (atom? y)) (compare_literals x y )]
    ; If the lists' lenghts are different, consider everything different
    [(not (equal? (length x) (length y))) (if_tcp x y)]
    ; Else, if the length of the lists is 1, compare the 
    [(equal? (length x) 1) (proc_length1_lists x y)]
    ;Else, they have length greater than 1
    [else (append (list (compare-expr (car x) (car y))) (compare-expr (cdr x) (cdr y)))]
    
    )
)

; Receives two lists that are arguments for the quote function
; Compare the lists. If they are equal, return 'x. 
; Else return (if TCP 'x 'y)
; Example: (compare_quotes '(a b) '(b c)) => '(if TCP '(a b) '(b c))
; Example: (compare_quotes '(a b) '(a b)) => ''(a b)
(define (compare_quotes x y)
    (cond 
          [(and (equal? x y) )  `',x]
          [else  (if_tcp `',x `',y)]
    )
)

; Receives two constant literals x and y
; Tests if the literals are equal, if the boolean special cases.
; Else, they are different
(define (compare_literals x y )
    (cond
           ; It counts for the case of #t #t, #f #f and whatever other
           ; possibilities where x = y
           [(and (equal? x y) )   x]
           ; In case (car x) is #t and (car y) is #t
           [(and (equal? x #t) (equal? y #f) ) 'TCP ]
           [(and (equal? x #f) (equal? y #t) )  '(not TCP)]
           [else  (if_tcp x y)]
    )    
)

